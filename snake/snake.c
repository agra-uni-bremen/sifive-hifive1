// See LICENSE for license details.

// executing out of SPI Flash at 0x20400000.

#include "helpers.h"

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "platform.h"
#include "plic/plic_driver.h"
#include "encoding.h"	//For CSRs
#include "sifive/devices/spi.h"

#include "oled_shield.h"
#include "font.h"
#include "display.h"
#include "framebuffer.h"

#define MAX_SNAKE_LENGTH 1024
#define MAX_DELAY 100

const uint8_t buttons[] =
{
	BUTTON_D,
	BUTTON_CTR,
	BUTTON_R,
	BUTTON_L,
	BUTTON_U,
	BUTTON_A,
	BUTTON_B
};

struct Food{
	uint8_t x, y;
	uint8_t valid;
};

enum Intelligence {
	i_none = 0,
	i_bold,
	i_safe,
	i_drunk,
	i_num
};

const char* intelligence_names[] = {
	"Human",
	"bold",
	"safe",
	"drunk",
	"NUM"
};


struct State{
	enum Direction{
		up = 0,
		down,
		left,
		right
	} direction, nextDirection;
	uint16_t length;
	enum Intelligence intelligent;
	struct Food food;
} state;
uint8_t nodelay = 0;
struct Snakesegment
{
	uint8_t x, y;
};
struct Snakesegment snake[MAX_SNAKE_LENGTH];


// Global Instance data for the PLIC
// for use by the PLIC Driver.
plic_instance_t g_plic;
// Structures for registering different interrupt handlers
// for different parts of the application.
typedef void (*interrupt_function_ptr_t) (plic_source);

//array of function pointers which contains the PLIC
//interrupt handlers
interrupt_function_ptr_t g_ext_interrupt_handlers[PLIC_NUM_INTERRUPTS];


/*Entry Point for PLIC Interrupt Handler*/
void handle_m_ext_interrupt()
{
    plic_source int_num  = PLIC_claim_interrupt(&g_plic);
	if ((int_num >=1 ) && (int_num < PLIC_NUM_INTERRUPTS))
	{
		g_ext_interrupt_handlers[int_num](int_num);
	}
	else
	{
		//exit(1 + (uintptr_t) int_num);
		printf("unhandled Interrupt %u", int_num);
		while(1){};
	}
	PLIC_complete_interrupt(&g_plic, int_num);
	//puts("completed interrupt\r\n");
}

void button_handler(plic_source int_num)
{
	int_num -= INT_GPIO_BASE;
	if(int_num ==  mapPinToReg(BUTTON_D))
	{
		if(state.direction != up)
			state.nextDirection = down;
	}
	else if(int_num == mapPinToReg(BUTTON_U))
	{
		if(state.direction != down)
			state.nextDirection = up;
	}
	else if(int_num == mapPinToReg(BUTTON_L))
	{
		if(state.direction != right)
			state.nextDirection = left;
	}
	else if(int_num == mapPinToReg(BUTTON_R))
	{
		if(state.direction != left)
			state.nextDirection = right;
	}
	else if(int_num == mapPinToReg(BUTTON_A))
	{
		state.intelligent++;
		state.intelligent %= i_num;
		printf("Switched snake intelligence to %s\n",
		       intelligence_names[state.intelligent]);
	}
	else if(int_num == mapPinToReg(BUTTON_B))
	{
		nodelay ^= 1;
	}
	else
	{
	}
	GPIO_REG(GPIO_RISE_IP) |= (1 << int_num);
	GPIO_REG(GPIO_FALL_IP) |= (1 << int_num);
}

//default empty PLIC handler
void invalid_global_isr(plic_source int_num)
{
	printf("Unexpected global interrupt %d!\r\n", int_num);
}

void setup_button_irq()
{
    PLIC_init(&g_plic,
            PLIC_CTRL_ADDR,
            PLIC_NUM_INTERRUPTS,
            PLIC_NUM_PRIORITIES);

	for(unsigned i = 0; i < sizeof(buttons); i++)
	{
		setPinInputPullup(buttons[i], 1);
		//enableInterrupt(buttons[i], 0);	//rise necessary?
		enableInterrupt(buttons[i], 1);	//fall
	    PLIC_enable_interrupt (&g_plic, INT_GPIO_BASE + mapPinToReg(buttons[i]));
	    PLIC_set_priority(&g_plic, INT_GPIO_BASE + mapPinToReg(buttons[i]), 2+i);
	    g_ext_interrupt_handlers[INT_GPIO_BASE + mapPinToReg(buttons[i])] = button_handler;
	    printf("Inited button %d\r\n", buttons[i]);
	}
}

void handle_m_time_interrupt()
{
	clear_csr(mie, MIP_MTIP);
}

uint8_t get_random_number()
{
	static uint8_t rand = 15;	//generated by fair dice roll
	rand += *(volatile uint64_t*)(CLINT_CTRL_ADDR + CLINT_MTIME);
	return rand;
}

void spawn_food()
{
	while(!state.food.valid)
	{
		state.food.x = get_random_number()%DISP_W;
		state.food.y = get_random_number()%DISP_H;

		state.food.valid = 1;
		for(unsigned i = 0; i < state.length; i++)
		{
			if(snake[i].x == state.food.x && snake[i].y == state.food.y)
				state.food.valid = 0;
		}
	}
	fb_set_pixel_direct(state.food.x, state.food.y, 1);
	printf("New food at %u %u\n", state.food.x, state.food.y);
}

void think()
{
	// intention
	state.nextDirection = state.direction;
	
	if(get_random_number() > 0xF5)
			state.nextDirection = get_random_number() % 3;

	if(state.food.valid)
	{
		int diffx = state.food.x - snake[0].x;
		int diffy = state.food.y - snake[0].y;
		if(abs(diffy) > DISP_H/2)
			diffy *= -1;
		if(abs(diffx) > DISP_W/2)
			diffx *= -1;

		if(abs(diffx) > 0)
		{
			if(diffx > 0)
				if(state.direction != left)
					state.nextDirection = right;
			if(diffx < 0)
				if(state.direction != right)
					state.nextDirection = left;
		}
		else
		{
			if(diffy > 0)
				if(state.direction != up)
					state.nextDirection = down;
				else
					state.nextDirection = left;
			if(diffy < 0)
				if(state.direction != down)
					state.nextDirection = up;
				
		}
	}

	if(state.intelligent == i_drunk && get_random_number() > 0xF5)
			state.nextDirection = get_random_number() % 3;

	// collision avoidance
	for(unsigned tries = 0; tries < 5; tries++)
	{
		unsigned goingToHit = 0;
		struct Snakesegment future = snake[0];
		future.x += state.nextDirection == left ? -1 : state.nextDirection == right ? 1 : 0;
		future.y += state.nextDirection == down ? 1 : state.nextDirection == up ? -1 : 0;
		future.x %= DISP_W;
		future.y %= DISP_H;

		for(uint16_t i = 1; i < state.length; i++)
		{
			if(snake[i].x == future.x && snake[i].y == future.y)
			{
				goingToHit = 1;
				printf("going to hit segment %i\n", i);
				if(tries == 0){
					int segment_diffx = snake[i-1].x - snake[i].x;
					int segment_diffy = snake[i-1].y - snake[i].y;
					if(abs(segment_diffx) > 1)
						segment_diffx *= -1;
					if(abs(segment_diffy) > 1)
						segment_diffy *= -1;

					if(segment_diffx > 0){
						state.nextDirection = left;
					} else if (segment_diffx < 0){
						state.nextDirection = right;
					} else if (segment_diffy > 0){
						state.nextDirection = up;
					} else if (segment_diffy < 0){
						state.nextDirection = down;
					} else {
						printf("Colliding segment direction unknown!?\n");
						state.nextDirection++; state.nextDirection %= 4;
					}
				} else {
					if(state.intelligent == i_safe)
						state.nextDirection += 1;
					else if(state.intelligent == i_bold || state.intelligent == i_drunk)
						state.nextDirection += 3;
					else {
						printf("Snake is of unknown intelligence.");
						state.nextDirection += 1;
					}
					state.nextDirection %= 4;
					printf("Avoidance heuristic fails, guessing dir %i\n", state.nextDirection);
				}
				break;
			}
		}
		if(!goingToHit)
			break;
	}
}

void reset_state()
{
	static unsigned num_resets = 0;
	state.direction = left;
	state.nextDirection = left;
	state.length = 10;
	state.intelligent = 1 + (num_resets % (i_num-1));
	spawn_food();
	memset(snake, 0, sizeof(struct Snakesegment) * MAX_SNAKE_LENGTH);
	for(unsigned i = 0; i < state.length; i++)
	{
		snake[i].x = (DISP_W/2)+i;
		snake[i].y = DISP_H/2;
		fb_set_pixel(snake[i].x, snake[i].y, 1);
	}
	fb_flush();
	printf("Switched snake intelligence to %s\n",
	       intelligence_names[state.intelligent]);
	num_resets++;
}

uint8_t snake_step()
{
	struct Snakesegment buf = snake[0];
	state.direction = state.nextDirection;
	switch (state.direction)
	{
	case up:
		snake[0].y--;
		break;
	case down:
		snake[0].y++;
		break;
	case left:
		snake[0].x--;
		break;
	case right:
		snake[0].x++;
		break;
	}
	snake[0].x %= DISP_W;
	snake[0].y %= DISP_H;

	for(unsigned i = 1; i < state.length; i++)
	{
		if(snake[0].x == snake[i].x && snake[0].y == snake[i].y)
		{
			//whoops, game over dude
			return 0;
		}
	}

	unsigned food_consumed = 0;
	if(state.food.valid)
	{
		if(snake[0].x == state.food.x && snake[0].y == state.food.y)
		{
			//we snake. we schlÃ¤ngel. we eat.
			state.food.valid = 0;
			state.length++;		//this may read off-by-one in snake array at long lengths.
			food_consumed = 1;
		}
	}

	fb_set_pixel_direct(snake[0].x, snake[0].y, 1);
	for(unsigned i = 1; i < state.length; i++)
	{
		struct Snakesegment buf2 = snake[i];
		snake[i] = buf;
		buf = buf2;		//wow, is it possible using more moves?
	}
	if(!food_consumed)
	{
		//last pixel gets deleted
		fb_set_pixel_direct(buf.x, buf.y, 0);
	}
	return 1;
}


void delayDifficulty()
{
	//Progress from 1 to 0
	float progress = ((float)(MAX_SNAKE_LENGTH - state.length))/MAX_SNAKE_LENGTH;
	if(state.intelligent)
		progress /= 4;	// I am speed
	if(!nodelay)
		sleep(1 + progress * MAX_DELAY);
}


int main (void)
{
	_init();
	//setup default global interrupt handler
	for (int gisr = 0; gisr < PLIC_NUM_INTERRUPTS; gisr++){
		g_ext_interrupt_handlers[gisr] = invalid_global_isr;
	}
	setup_button_irq();

	// Enable Global (PLIC) interrupts.
	set_csr(mie, MIP_MEIP);

	// Enable all interrupts
	set_csr(mstatus, MSTATUS_MIE);

	oled_init();
	fb_init();


	while (1) {
		reset_state();
		while(snake_step() && state.length < MAX_SNAKE_LENGTH)
		{
			delayDifficulty();
			if(!state.food.valid && (get_random_number() > 0xEF))
			{
				spawn_food();
				printf("Current Score: %i\n", state.length);
			}
			if(state.intelligent)
				think();
		}
		fadeOut(2000);
		oled_clear();
		setContrast(255);

		printText("\n    GAME OVER\n");
		uint8_t buf[5];
		printText("\nScore: ");
		sprintf(buf, "%04u\n\n", state.length);
		printText(buf);
		printText(intelligence_names[state.intelligent]);
		printText(" Snake");
		sleep(5000);

		cls();
		fb_init();
		fb_flush();
	}
}
